{"meta":{"title":"Candy?","subtitle":"Link, cut, time doesn't stop.","description":"Meow~~","author":"Candy?","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-07-09T02:08:31.000Z","updated":"2017-07-09T02:09:00.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-07-09T02:04:47.000Z","updated":"2017-07-09T02:04:47.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2017-07-09T03:34:49.000Z","updated":"2017-07-10T06:30:01.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"曾经是一个在弱校挣扎的OIer 现在只是平度一中2015级崇真1班的一名学生 喜欢信息，喜欢数学 喜欢deemo 不再是OIer后，没什么好写的了。原博客还在那里，又搭建了这个地方。也许什么时候心血来潮会更新一篇文章。 应该没什么人会看到吧，我就随意的写了。"}],"posts":[{"title":"Candy?'s 不饱和度","slug":"unsaturation","date":"2017-07-10T12:13:04.000Z","updated":"2017-07-10T12:19:36.000Z","comments":true,"path":"2017/07/10/unsaturation/","link":"","permalink":"http://yoursite.com/2017/07/10/unsaturation/","excerpt":"题目背景化学老师让同学们出题！昌老师担任有机组组长！ Candy?出了一道数不饱和度的题目，昌老师不会做所以拒绝接受！！！ 于是Candy?又出了一道用 $Polya定理$ 数卤代烃个数的题目，然后把原来这道题扔给了你。","text":"题目背景化学老师让同学们出题！昌老师担任有机组组长！ Candy?出了一道数不饱和度的题目，昌老师不会做所以拒绝接受！！！ 于是Candy?又出了一道用 $Polya定理$ 数卤代烃个数的题目，然后把原来这道题扔给了你。 题目内容你有一个有多个环的烷烃的键线式，求他的不饱和度。 值得注意的是，键线式的C原子并没有标出来，并且线可能是直线、斜线或者曲线，上面的C原子数目不定。 下面有几个例子，其中X表示线，0表示空： 1 7XXXXXXX 是一个饱和链烃，不一定有几个C，不饱和度是0. 4 7XXXXXXXXOOOOOXXOOOOOXXXXXXXX 最简单的情况就是一个4个C的环烷烃，不饱和度为1. 3 7XXXXX000X0X0X000XXXXX 这是一个有两个环的烃，不饱和度是2 它可能张这个样子 4 7000X00000X0X000X000X00XXXXX0 她的不饱和度是1，样子自行脑补，我懒得画了。 输入输出 &amp; 数据规模输入一个n行m列的矩阵，X表示线，0表示空，是一个有机物的键线式。输出他的不饱和度 $n,m &lt; 1000$ 样例Sample Input123454 7XXXXXXXXOOOOOXXOOOOOXXXXXXXX Sample Output11 下面是题解和标程 题解最初的想法来自2016.6.26 那时候觉得复杂环式结构的烷烃不饱和度好神奇，从图论的角度考察了一下，还写了一篇周记。 一年后做化学题又想到了这个东西，拿着它去考灰哥有没有忘记我的周记，结果他随手用了另一种方法，好快好有趣，貌似正确性有待商榷。我尝试卡了一下，发现好像只有平面图成立，然后证明了一下成功了。 后来我发现那就是欧拉公式，并且我的证明和他一模一样，如果我早出生是不是可以叫Candy?公式……. 扔定理就跑： 定理1：任意一个烷烃可以看成无向简单图$G(V,E)$，那么他的不饱和度为$$\\mid E\\mid - \\mid V\\mid +1$$其中$V$是点集，$E$是边集 定理2：如果由烷烃得到的图$G$是平面图，那么$$它把平面划分成的区域数(除去最外围平面) = \\mid E\\mid - \\mid V\\mid +1$$平面图就是能画在平面上使得边仅在顶点处相交的图。 证明去看欧拉公式的吧，不想写。 这样一来对于化学题，一眼就看出不饱和度了。 但是出成OI题的话，如果标出C的位置可以用数分子式的方法很快水过去，所以才变成不确定C原子，这样的话就需要得到上面的定理然后搜一下0组成的连通块数就好了，小心外圈的0没有连起来。 大多数人应该不会这个方法吧，昌老师就不会 Candy? : 你怎么知道这个方法的 (惊恐) 某冰 : 不就应该是这样吗 (一脸鄙视) 标程123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 105;int n, m, ans;char s[N][N]; int dfc, vis[N][N];inline bool valid(int x, int y) &#123;return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt;= n &amp;&amp; y &lt;= m &amp;&amp; s[x][y] != 'X' &amp;&amp; !vis[x][y];&#125;void dfs(int x, int y) &#123; vis[x][y] = dfc; if(valid(x-1, y)) dfs(x-1, y); if(valid(x+1, y)) dfs(x+1, y); if(valid(x, y-1)) dfs(x, y-1); if(valid(x, y+1)) dfs(x, y+1);&#125;int main() &#123; freopen(\"in\", \"r\", stdin); scanf(\"%d %d\", &amp;n, &amp;m); for(int i=1; i&lt;=n; i++) scanf(\"%s\", s[i]+1); n++; m++; for(int i=0; i&lt;=n; i++) for(int j=0; j&lt;=m; j++) if(s[i][j] != 'X' &amp;&amp; !vis[i][j]) dfc++, dfs(i, j); printf(\"%d\", dfc-1);&#125;","categories":[],"tags":[{"name":"problem, article, chemistry, math","slug":"problem-article-chemistry-math","permalink":"http://yoursite.com/tags/problem-article-chemistry-math/"}]},{"title":"polynomial","slug":"2","date":"2017-07-09T11:52:11.000Z","updated":"2017-07-10T06:36:27.000Z","comments":true,"path":"2017/07/09/2/","link":"","permalink":"http://yoursite.com/2017/07/09/2/","excerpt":"我只是搬一篇以前的文章来测试 形式幂级数沉迷多项式，无法自拔… 不具体写了看笔记本，这里稍微记一下。 目录 多项式的各种运算 伯努利数 拉格朗日反演","text":"我只是搬一篇以前的文章来测试 形式幂级数沉迷多项式，无法自拔… 不具体写了看笔记本，这里稍微记一下。 目录 多项式的各种运算 伯努利数 拉格朗日反演 任意模数卷积我的三模数ntt跑得好慢，然后拆系数fft跑的好快 设$M = \\lceil P \\rceil$，将整数表示成$k\\cdot M+b$的形式 对$x$和$y$进行卷积，分别表示称$a\\cdot M + b,\\ c\\cdot M + d$$$(a\\cdot M + b)\\cdot (c\\cdot M + d) = ac M^2 + (ad+bc)M + bd$$对$a,b,c,d$进行dft和idft即可 每个数大小在$10^{14}$级别，可以使用复数下fft，共进行7次运算 通常M取$32768=2^{15}$ 根据猜测，系数表示不溢出double点值表示就不会溢出double。这玩意应该只能承受一次点值乘法 123456789101112131415161718void mul_any(int *x, int *y, int lim) &#123; for(int i=0; i&lt;lim; i++) &#123; a[i].x = x[i] &gt;&gt; 15; b[i].x = x[i] &amp; 32767; c[i].x = y[i] &gt;&gt; 15; d[i].x = y[i] &amp; 32767; &#125; dft(a, 1); dft(b, 1); dft(c, 1); dft(d, 1); for(int i=0; i&lt;n; i++) &#123; cd _a = a[i], _b = b[i], _c = c[i], _d = d[i]; a[i] = _a * _c; b[i] = _a * _d + _b * _c; c[i] = _b * _d; &#125; dft(a, -1); dft(b, -1); dft(c, -1); for(int i=0; i&lt;lim; i++) &#123; ll _a = (ll) floor(a[i].x + 0.5) %mo, _b = (ll) floor(b[i].x + 0.5) %mo, _c = (ll) floor(c[i].x + 0.5) %mo; printf(\"%lld \", ((_a &lt;&lt; 30) %mo + (_b &lt;&lt; 15) %mo + _c) %mo); &#125;&#125; 以下复杂度均为$T(n) = T(n/2) + O(nlogn) =O(nlogn)$ 模板在最下方 多项式求逆元求$$A(x) * B(x) \\equiv 1 \\pmod {x^n}$$ 注意到这时候$A(x)*B(x)$的$1…n-1$次项系数为0 用倍增的思想，已知$\\mod x^{\\lceil \\frac{l}{2} \\rceil}$的逆元$B_0(x)$求$\\mod x^l$下的逆元$B(x)$ $l=1$时，$b_0 = a_0^{-1}$，可以发现多项式有逆的充要条件是常数项有逆 两式相减，然后平方，同乘$A(x)$，得到$$B(x) \\equiv B_0(x) (2 - A(x) B_0(x)) \\pmod {x^l}$$ 处理$\\mod x^l$时，$l$就是当前的次数界，次数$\\ge l$的都整除没了。 可以理解为只关心前l项 多项式开根求$$B^2(x) \\equiv A(x) \\pmod {x^n}$$同样倍增的思想 已知$\\mod x^{\\lceil \\frac{l}{2} \\rceil}$的平方根$B_0(x)$求$\\mod x^l$下的平方根$B(x)$ $l=1$时，$b_0 \\equiv \\sqrt{a_0} \\pmod x$，可能需要二次剩余 移项化简后得到$$B(x) \\equiv 2^{-1}\\cdot (B_0(x) + A(x) * B_0^{-1}(x)) \\pmod{x^n}$$同时还需要求逆… 牛顿迭代法给出$G(x)$，求$F(x)$，$$G(F(x)) \\equiv 0 \\pmod{x^n}$$倍增的思想。将$G(F(X))$在$F_0(x)$处泰勒展开得到$$F(x) \\equiv F_0(x) - \\frac{G(F_0(x))}{G’(F_0(x))} \\pmod{x^l}$$也可以用这个式子求逆元和开根，最后的结果式子一样。 多项式求ln和exp就是和对应的麦克劳林级数复合，所以要求常数项为0 多项式求ln给出$F(x) = 1 + \\sum_{i \\ge 1}f_ix^i$ 求一下导$$\\ln F(x) = \\int \\frac{F’(x)}{F(x)}dx$$ 多项式求exp给出$A(x) = \\sum_{i \\ge 1}a_ix^i$$$e^{A(x)} - B(x) \\equiv 0 \\pmod {x^n}$$取对数后使用牛顿迭代法$$B(x) = B_0(x)(1 - \\ln B_0(x) + A(x))$$ 多项式k次幂当$A(x)$的常数项为1$$A(x)^k = exp(k \\ln A(x))$$ 否则提取最低次项$ax^d$$$A(x)^k = (ax^d)^k (\\frac{A(x)}{ax^d})^k$$ 伯努利数wiki 用来解决等幂求和问题$$\\begin{align}\\sum{i=0}^{n-1} i^m = \\frac{1}{m+1}\\sum{i=0}^m \\binom{m+1}{i}B_i^- n^{m+1-i} \\Sm(n) = \\sum{i=1}^{n} i^m = \\frac{1}{m+1}\\sum_{i=0}^m \\binom{m+1}{i}B_i^+ n^{m+1-i} \\\\end{align}$$复杂度与幂次有关 除了$B_1$，其他奇数项都是0。$B_1^+ = \\frac{1}{2},B_1^-=-\\frac{1}{2}$ $0^0=1$ 递推关系令$n=1, m\\neq 0$,$$\\sum_{i=0}^m \\binom{m+1}{i} B_i ^ - = 0,\\ B_0 = 1, B_1 ^- = -\\frac{1}{2}$$ 指数型生成函数对于$B^-$,$$\\sum {i=0} ^ \\inftyB i \\frac{x^i}{i!} =\\frac{x}{e^x - 1} =( \\sum _ {i=0}^\\infty \\frac{x^i}{(i+1)!})^{-1}$$ 使用多项式求逆元即可预处理伯努利数. 求$\\mod x^{n+1}$意义下逆元 预处理任意模数伯努利数的模板 拉格朗日反演复合逆(反函数)： 没有常数项的$f(x), g(x)$，$f(g(x))=x$，那么互为复合逆，$f_1g_1=1,g(f(x))=x$ 用拉格朗日反演可以$O(nlogn)$求复合逆某一项的系数$$[x^n]g(x) = \\frac{1}{n}[ \\omega ^ {n-1} ] (\\frac{ \\omega }{f(\\omega)}) ^ n$$可以配合多项式k次幂使用。 生成函数中出现x之后可以用啦。 模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182namespace ntt &#123; int g = 3, rev[N]; void dft(int *a, int n, int flag) &#123; int k = 0; while((1&lt;&lt;k) &lt; n) k++; for(int i=0; i&lt;n; i++) &#123; rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;(k-1)); if(i &lt; rev[i]) swap(a[i], a[rev[i]]); &#125; for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m = l&gt;&gt;1, wn = Pow(g, flag == 1 ? (P-1)/l : P-1-(P-1)/l); for(int *p = a; p != a+n; p += l) for(int k=0, w=1; k&lt;m; k++, w = (ll)w*wn %P) &#123; int t = (ll) w * p[k+m] %P, r = p[k]; p[k+m] = (r - t + P) %P; p[k] = (r + t) %P; &#125; &#125; if(flag == -1) &#123; ll inv = Pow(n, P-2); for(int i=0; i&lt;n; i++) a[i] = a[i] * inv %P; &#125; &#125; void inverse(int *a, int *b, int l) &#123; static int t[N]; if(l == 1) &#123;b[0] = Pow(a[0], P-2); return;&#125; inverse(a, b, l&gt;&gt;1); int n = l&lt;&lt;1; for(int i=0; i&lt;l; i++) t[i] = a[i], t[i+l] = 0; dft(t, n, 1); dft(b, n, 1); for(int i=0; i&lt;n; i++) b[i] = (ll) b[i] * (2 - (ll) t[i] * b[i] %P + P) %P; dft(b, n, -1); for(int i=l; i&lt;n; i++) b[i] = 0; &#125; void sqrt(int *a, int *b, int l) &#123; static int t[N], ib[N]; if(l == 1) &#123;b[0] = 1; return;&#125; sqrt(a, b, l&gt;&gt;1); int n = l&lt;&lt;1; for(int i=0; i&lt;l; i++) t[i] = a[i], t[i+l] = 0, ib[i] = ib[i+l] = 0; inverse(b, ib, l); dft(t, n, 1); dft(b, n, 1); dft(ib, n, 1); for(int i=0; i&lt;n; i++) b[i] = (ll) inv2 * (b[i] + (ll) t[i] * ib[i] %P) %P; dft(b, n, -1); for(int i=l; i&lt;n; i++) b[i] = 0; &#125; void ln(int *a, int *b, int l) &#123; static int da[N], ia[N]; int n = l&lt;&lt;1; for(int i=0; i&lt;n; i++) da[i] = ia[i] = 0; for(int i=0; i&lt;l-1; i++) da[i] = (ll) (i+1) * a[i+1] %P; inverse(a, ia, l); dft(da, n, 1); dft(ia, n, 1); for(int i=0; i&lt;n; i++) b[i] = (ll) da[i] * ia[i] %P; dft(b, n, -1); for(int i=l-1; i&gt;0; i--) b[i] = (ll) inv[i] * b[i-1] %P; b[0] = 0; for(int i=l; i&lt;n; i++) b[i] = 0; &#125; void exp(int *a, int *b, int l) &#123; static int t[N]; if(l == 1) &#123;b[0] = 1; return;&#125; exp(a, b, l&gt;&gt;1); int n = l&lt;&lt;1; for(int i=0; i&lt;n; i++) t[i] = 0; ln(b, t, l); for(int i=0; i&lt;l; i++) t[i] = (a[i] - t[i] + P) %P; t[0] = (t[0] + 1) %P; dft(b, n, 1); dft(t, n, 1); for(int i=0; i&lt;n; i++) b[i] = (ll) b[i] * t[i] %P; dft(b, n, -1); for(int i=l; i&lt;n; i++) b[i] = 0; &#125; void power(int *a, int k, int l) &#123; static int t[N]; int n = l&lt;&lt;1; for(int i=0; i&lt;n; i++) t[i] = 0; ln(a, t, l); for(int i=0; i&lt;l; i++) t[i] = (ll) k * t[i] %P; for(int i=0; i&lt;n; i++) a[i] = 0; exp(t, a, l); &#125;&#125;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"test","slug":"1","date":"2017-07-09T03:51:06.000Z","updated":"2017-07-09T10:28:11.000Z","comments":true,"path":"2017/07/09/1/","link":"","permalink":"http://yoursite.com/2017/07/09/1/","excerpt":"","text":"Hello, I’m a test post1234567 abcdefg 123456#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123; puts(\"hello\");&#125; $$f(x) = \\frac{x\\ln x + x^3}{e^x}$$ blah blah blah hi","categories":[],"tags":[{"name":"cat","slug":"cat","permalink":"http://yoursite.com/tags/cat/"}]}]}